# -*- coding: utf-8 -*-
"""Assignment2v4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wVuHXBj_WQesvo7jW2ng7LwP8o482AtW
"""

class Vertex:
  def __init__(self, graphLetter, graphNum, indexInGraph):
    self.graphLetter = graphLetter
    self.graphNum = graphNum
    self.indexInGraph = indexInGraph
    self.label = None
    self.name = f"({graphLetter},{graphNum},{indexInGraph})"
    self.nameTuple = (graphLetter, graphNum, indexInGraph)

  def __repr__(self):
    return f"Vertex({self.name}, label={self.label})"

  def __eq__(self, other):
    return ( self.graphLetter == other.graphLetter and self.graphNum == other.graphNum and self.indexInGraph == other.indexInGraph )

  def __lt__(self, other):
    return self.nameTuple < other.nameTuple

  def __hash__(self):
    return hash((self.graphLetter, self.graphNum, self.indexInGraph))

Adjacencies = {}
Vertices = {}

Vertices.clear()
Adjacencies.clear()

for v in list(globals().values()):
  if isinstance(v, Vertex):
    v.label = None

def AddAdjacency(u, v):
  global Adjacencies
  if u == v:
    return
  if u not in Adjacencies:
    Adjacencies[u] = []
  if v not in Adjacencies:
    Adjacencies[v] = []
  if v in Adjacencies[u]:
    return
  Adjacencies[u].append(v)
  Adjacencies[v].append(u)


def MergeGraphs(vToMerge, vToRemove):
  global Adjacencies, Vertices

  if vToRemove.nameTuple not in Vertices:
    return
  if vToRemove not in Adjacencies:
    return

  prevNeighbors = Adjacencies[vToRemove]
  for neighbor in list(prevNeighbors):
    if neighbor != vToMerge:
      AddAdjacency(vToMerge, neighbor)
    if vToRemove in Adjacencies[neighbor]:
      Adjacencies[neighbor].remove(vToRemove)

  del Adjacencies[vToRemove]
  del Vertices[vToRemove.nameTuple]

def C(n,r,m,inner):
  global Adjacencies, Vertices
  Adjacencies = {}
  Vertices = {}

  # Initialize vertices
  for j in range(m):
      for k in range(n):
          Vertices[("A", j, k)] = Vertex("A", j, k)
          Vertices[("B", j, k)] = Vertex("B", j, k)

  # Initialize adjacency lists
  for j in range(m):
      for k in range(n):
          Adjacencies[Vertices[("A", j, k)]] = []
          Adjacencies[Vertices[("B", j, k)]] = []

  # Connect existing vertices
  for j in range(m):
    for k in range(n):

        u = Vertices[("A", j, k)]
        v = Vertices[("A", j, (k + 1) % n)]
        AddAdjacency(u, v)

        b = Vertices[("B", j, k)]
        bLeft  = Vertices[("B", j, (k + r) % n)]
        bRight = Vertices[("B", j, (k - r) % n)]
        AddAdjacency(b, bLeft)
        AddAdjacency(b, bRight)

        AddAdjacency(Vertices[("A", j, k)], Vertices[("B", j, k)])

  index = n // 2

  for j in range(m - 1):
    if inner:
      vToMerge = Vertices[("A", j, index)]
      vToRemove = Vertices[("A", j + 1, 0)]
    else:
      vToMerge = Vertices[("B", j, index)]
      vToRemove = Vertices[("B", j + 1, 0)]

    MergeGraphs(vToMerge, vToRemove)

  for vertex, adjacencies in list(Adjacencies.items()):
    Adjacencies[vertex] = sorted(
        adjacencies,
        key = lambda v: (v.graphNum, v.graphLetter, v.indexInGraph),
        reverse = not inner,
    )

C(n=5, r=2, m=3, inner=True)
for key in list(Vertices.keys())[:5]:
    v = Vertices[key]
    _ = Adjacencies[v]

"""# ============

Code for assigning labels:
"""

from collections import deque

next = deque()
fel = set()             #Final Edge List (weights)
unusedEdge = deque()
felMax = 0              #Gloabl Edge Weight Maximum

def printEdge(vA, vB, weight, src=""):
    print(f"EDGE {vA.name} ({vA.label}) + {vB.name} ({vB.label}) = {weight} {src}")

def AddWeight(weight):
  global felMax, fel, unusedEdge
  if weight in fel:
    return

  fel.add(weight)
  if weight > felMax:
    for i in range(felMax + 1, weight):
      unusedEdge.append(i)
    felMax = weight

def UpdateEdges(vertex):
  global unusedEdge
  for adj in Adjacencies[vertex]:
    if adj.label is not None:
      w = vertex.label + adj.label
      AddWeight(w)
      if w in unusedEdge:
        unusedEdge.remove(w)

def UpdateVertex(source, examinee, label, weight, src="", verbose=False):
  examinee.label = label
  AddWeight(weight)
  if verbose:
    printEdge(source, examinee, weight, src)
  UpdateEdges(examinee)

def AcceptibleLabel(examined, considered):
  localFel = fel
  localAdj = Adjacencies

  for adj in localAdj[examined]:
    if adj.label is not None:
      if (considered + adj.label) in localFel:
        return False
    for adjadj in localAdj[adj]:
      if adjadj.label == considered:
        return False
  return True

def AssignLabels(startVertex, verbose=False):
  global next, fel, unusedEdge, felMax, Vertices

  for v in Vertices.values():
    v.label = None

  next = deque()
  fel = set()
  unusedEdge = deque()
  felMax = 0

  startVertex.label = 1
  firstAdj = Adjacencies[startVertex][0]
  firstAdj.label = 1

  next.append(startVertex)
  next.append(firstAdj)
  AddWeight(2)

  if verbose:
    printEdge(startVertex, firstAdj, 2, "[initial]")

  # MAIN LOOP
  visited = set()
  while next:
    Source = next.popleft()

    if Source in visited:
      continue
    visited.add(Source)

    for Examinee in Adjacencies[Source]:
      if Examinee.label is None:
        continue

    reused = False
    for weight in list(unusedEdge):
      consideredWeight = weight
      consideredLabel = consideredWeight - Source.label

      if consideredLabel <= 0:
        continue

      if AcceptibleLabel(Examinee, consideredLabel):
        UpdateVertex(Source, Examinee, consideredLabel, consideredWeight,src="[from unusedEdge]", verbose=verbose)
        unusedEdge.remove(weight)
        reused = True
        break

    if reused:
      next.append(Examinee)
      continue

    consideredWeight = felMax + 1
    consideredLabel = consideredWeight - Source.label

    while consideredLabel <= 0 or not AcceptibleLabel(Examinee, consideredLabel):
      consideredWeight += 1
      consideredLabel = consideredWeight - Source.label

    UpdateVertex(Source, Examinee, consideredLabel, consideredWeight,
                  src="[new weight]", verbose=verbose)
    next.append(Examinee)
  return fel, list(unusedEdge)

"""# ==============

Testing Code:
"""

def RunSingle(n=5, r=2, m=2000, inner=True, verbose=False):
  C(n=n, r=r, m=m, inner=inner)

  startKey = ("A", 0, 0)

  startVertex = Vertices[startKey]
  felSet, unusedEdges = AssignLabels(startVertex, verbose=verbose)
  maxEdge = max(felSet) if felSet else None

  print("\n===Single Run Summary")
  print(f"n={n}, r={r}, m={m}, inner={inner}")
  print(f"Final Edge List Max : {maxEdge}")
  print(f"Unused Edge Count   : {len(unusedEdges)}")
  print(f"Unused Edge Sample  : {unusedEdges[:20]}")

  return {
        "n": n,
        "r": r,
        "m": m,
        "inner": inner,
        "fel": felSet,
        "unused_edges": unusedEdges,
        "max_edge_weight": maxEdge,
  }


def RunM(n=5, r=2, mVal=None, inner=True, verbose=False):
  if mVal is None:
    mVal = [100, 250, 500, 750, 1000, 1250, 1500, 1750, 2000]
  results = []
  print("\n===M Values")
  for m in mVal:
    C(n=n, r=r, m=m, inner=inner)

    startKey = ("A", 0, 0)
    startVertex = Vertices[startKey]

    felSet, unusedEdges = AssignLabels(startVertex, verbose=verbose)
    maxEdge = max(felSet) if felSet else None

    print(f"m={m} -> unusedEdges={len(unusedEdges)} (max edge: {maxEdge})")

    results.append({
        "m" : m,
        "unusedEdgeCount" : len(unusedEdges),
        "maxEdgeWeight" : maxEdge,
    })
  return results

if __name__ == "__main__":
  singleResult = RunSingle(n=5,r=2,m=2000,inner=True,verbose=False)


  mResults = RunM(
      n=5, r=2,
      mVal=[100,250,500,750,1000,1250,1500,1750,2000],
      inner=True, verbose=False
  )

  print("\n===Collected Results===")
  for res in mResults:
    print(res)

v0 = Vertices[("A",0,0)]
fel, unusedEdges = AssignLabels(v0)
print(f"\nFinal Edge List : {fel}")
print(f"Unused Edges : {unusedEdges}")